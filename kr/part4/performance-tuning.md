성능 개선
==================

Axon 3 버전에 맞게 수정 예정

이번 장은 운영 환경 수준의 성능을 내기 위해 준비해야 할 점검표와 몇 가지 지침들을 포함하고 있습니다. 지금까지 직접 구현한 명령 처리 로직과 사가(Saga)들을 테스트하기 위해 테스트 픽스쳐(fixture)를 사용해 왔을 것입니다. 운영 환경은 테스트 환경처럼 실수나 결함을 여류롭게 처리할 수 있는 환경이 아닙니다. Aggregate들은 더 오래 살아 있을 것이고 더 자주 그리고 동시적으로 사용이 될 것입니다. 추가 성능 및 안정성을 가지기 위해서, 특정 요구 사항에 맞게 설정 사항을 조정하는 것이 좋습니다.

데이터베이스 인텍스와 컬럼 타입
=================================

SQL 데이터베이스
-------------

예를 들어 하이버네이트와 같은 JPA 구현체를 사용하여 자동으로 생성된 테이블들을 가지고 있다면, 각각의 테이블에 맞는 인덱스를 모두 설정하지 못했을 것입니다. 이벤트 저장소의 다른 사용 용도에 따라 최적의 성능을 낼 수 있도록 다른 인덱스가 설정될 필요가 있습니다. 다음의 목록을 통해, 기본 ```EventStorageEngine``` 구현체에서 사용되는 다른 유형의 질의에 추가해야 할 인덱스들을 알 수 있을 것입니다.

-   이벤트 정렬과 로딩과 같은 일반적인 작업에 사용: 'DomainEventEntry' 테이블은 `aggregateIdentifier`와 `sequenceNumber` 칼럼을 가지며, 두 칼럼은 유니크 인덱스로 사용됩니다. 그리고 `eventIdentifier` 칼럼을 유니크 인덱스로 사용합니다.

-   스냅숏 생성: 'SnapshotEventEntry' 테이블은 `aggregateIdentifier`와 `eventIdentifier`를 칼럼으로 가지며, `aggregateIdentifier`, `sequenceNumber` 그리고 `type`들을 조합하여 primary key로 사용합니다. 또한 `eventIdentifier` 칼럼을 유니크 인덱스로 사용합니다.

-   사가(Saga): 'AssosiationValueEntry' 테이블은 `assosiationKey`, `assosiationValue`, `sagaId` 그리고 `sagaType`들을 칼럼으로 가집니다. `sagaType`, `associationKey` 그리고 `associationValue`칼럼들을 일반 인덱스(유일하지 않은)로 사용하며, `sagaId`과 `sagaType`를 유일하지 않은 또 다른 인덱스로 사용합니다.

예를 들어 하이버네이트가 생성한 기본 칼럼 길이로 작동하는 데 문제는 없지만 최적은 아닐 수 있습니다. 한 예로, UUID는 항상 같은 길이를 가지게 됩니다. 따라서 255자의 가변 길이 칼럼 대신, aggregate 식별자에 대해 36자리를 고정 길이로 가지는 칼럼을 사용하는 것이 좋습니다.

DomainEventEntry 테이블의 '타임스탬프' 칼럼은 ISO 8601 타임스탬프들만을 저장합니다. UTC 타임존내의 모든 시간을 저장해야 한다면, 24자 길이의 칼럼을 사용해야 합니다. 만약 다른 타임 존을 사용한다면, 28자 길이까지 가능합니다. 타임 스탬프값은 항상 같은 길이의 값을 가지기 때문에, 가변 길이의 칼럼을 사용하는 것은 일반적으로 불필요합니다.

> **경고**
>
> 모든 시간값(타임스탬프)를 UTC 형식으로 저장하는 것을 강력히 권고합니다. 일광 절약 시간제(Day-light Savings Time)를 사용하는 나라들에서, 현지 시각으로 시간 값을 저장하면 나중에 시간대 변경 전후에 생성된 이벤트들을 정렬할 때 에러가 발생 될 수 있습니다. 하지만 UTC 형식으로 시간 값을 저장하면 에러는 발생하지 않습니다. 일부 서버들은 UTC 형식을 사용하도록 설정이 되어 있지만, 시간 값을 UTC 형식으로 변경하도록 이벤트 저장소를 설정해야 합니다.

DomainEventEntry 테이블의 'type' 칼럼은 aggregate의 타입 식별자들을 저장합니다. 일반적으로, 타입 식별자들은 aggregate의 '간단한 이름' 입니다. 스프링의 악명높은 'AbstractDependencyInjectionSpringContextTests'는 45자나 됩니다. 다시 말하지만, 더욱 더 짧은 길이의(하지만 가변의) 항목이면 충분합니다.

몽고DB
-------

기본적으로, MongoEventStore는 수정 작업이 필요한 인덱스만을 생성합니다. 즉, 이벤트 스토어가 생성될 때, "Aggregate Identifier", "Aggregate Type" 그리고 "Event Sequence"의 조합으로 이루어진 유일(unique)한 인덱스가 생성됩니다. 하지만, MongoEventStore를 사용하면서 특정 작업을 위해 필요한 인덱스들을 추가할 수 있습니다.

조회를 위한 질의 최적화와 업데이트 속도 간의 균형은 항상 필요하다는 것에 유의하세요. 로드(load) 테스트는 최상의 성능을 위해 필요한 인덱스를 찾는 가장 좋은 방법입니다.

-   -   일반적인 작업에 사용: "domain events"라는 기본 이름을 가지는 도메인 이벤트 컬렉션의 "aggregateIdentifier", "type" 그리고 "sequenceNumber"들로 이루어진 인덱스를 자동으로 생성합니다.

-   스냅숏 생성: 스냅숏 이벤트 컬렉션(기본 이름: "snapshotevents")의 "aggregateIdentifier", "type" 그리고 "sequenceNumber"로 유니크(unique) 인덱스를 생성합니다.

-   이벤트 리플레이(replaying): 도메인 이벤트(기본 이름: "domainevents") 컬렉션의 "timestamp"와 "sequenceNumber"로 구성된 유니크하지 않은 일반 인덱스를 생성합니다.

-   사가(Saga): 사가(기본 이름: "sagas") 컬렉션의 "sagaIdentifier"로 유니크 인덱스를 생성합니다. 그리고 사가(기본 이름: "sagas") 컬렉션의 "sagaType", "associations.key" 그리고 "associations.value" 속성들로 구성된 인덱스를 생성합니다.

캐시 사용
=======

잘 설계된 명령 처리자 모듈은 캐싱을 구현하여 사용할 때 어떤 문제가 일으키지 않아야 합니다. 특히 이벤트 소싱을 사용할 때, 이벤트 스토어로부터 aggregate를 로딩하는 것은 비싼 작업입니다. 적절하게 설정된 캐시를 사용하면, aggregate 로딩을 메모리 기반 작업으로 변경할 수 있습니다.

캐시를 사용하기 위한 몇 가지 지침들은 아래와 같습니다.

-   작업 단위(Unit Of Work)는 기능상의 이유로 롤백을 수행할 필요가 없습니다. 롤백은 aggregate가 올바르지 않은 상태로 변경되었다는 것을 의미합니다. Axon은 관련된 캐시 항목들을 자동으로 없애버립니다. 다음 요청은 aggregate를 이벤트로부터 재구성하도록 강제합니다. 만약 잠재적인(기능적) 반환 값으로 예외를 사용한다면, `RollbackConfiguration`을 커맨드 버스에 설정할 수 있습니다. 기본적으로, 작업 단위는 런타임 예외가 발생하면 롤백 처리를 하게 됩니다.

-   단일 aggregate를 위한 모든 명령은 aggregate를 캐시하고 있는 서버(machine)에 전달되어야 합니다. 즉, 해당 명령들은 일관되게 같은 서버(machine)로 라우팅 되어야 합니다. 단 해당 서버가 정상 작동하는 동안에만 해당합니다. 같은 서버로 명령들을 라우팅하는 것은 캐시를 정상적으로 사용할 수 있도록 합니다. 더는 유효하지 않은(stale) 캐시를 사용하여 명령을 실행하면, 이벤트를 이벤트 저장소에 저장할 수 없습니다.

-   알맞은 유효(time to live) 및 유휴 시간(time to idle)을 설정하세요. 기본적으로, 캐시는 분 단위의 비교적 짧은 시간 동안 살아 있는 경향이 있습니다. 일관관 라우팅을 하는 명령 처리 컴포넌트에 대해, 보통 좀 더 긴 유휴 시간과 유효 시간을 설정하는 것이 좋습니다. 좀 더 긴 유효 시간과 유휴 시간으로, 캐시가 만료되어 aggregate를 이벤트들로부터 재구성하는 것을 방지할 수 있습니다. 유효 시간은 aggregate이 살아 있어야 하는 시간과 같게 설정해야 합니다.

스냅숏 사용
============

스냅숏을 생성하면, 많은 수의 이벤트들을 다시 적재하고 리플레이하지 않아도 됩니다. 단일 스냅숏은 특정 시간의 전체 aggregate의 상태를 포함합니다. 하지만 스냅숏을 생성하는 프로세스 자체는 처리 시간이 소요됩니다. 따라서, 스냅숏을 생성하고 스냅숏을 사용하여 많은 이벤트를 다시 읽어 들이는 시간 간의 균형이 필요합니다.

이벤트의 개수를 명시하여 스냅숏을 생성해야 하는 애플리케이션이 있을 수 있고, 시간 간격을 기반으로 스냅숏을 생성해야 하는 애플리케이션이 있을 수 있습니다. 따라서 어떤 방법을 선택하던 오랜 기간 살아 있어야 하는 aggregate을 가지고 있다면, 반드시 스냅숏을 사용해야 합니다.

스냅숏에 대해 더 자세한 내용을 알고 있다면, [스냅숏 지정](../part3/repositories-and-event-stores.html#스냅샷-지정)을 살펴보세요.


이벤트 직렬화 개선
=======================

XStream 직렬화 객체
------------------

XStream은 설정할 수 있고 확장성이 매우 좋습니다. 만약 평범한 `XStreamSerializer`를 사용한다면, 빠르게 개선 시킬 방법들이 있습니다. XStream은 패키지 명과 이벤트 클래스 명들에 대한 별명(alias)들을 사용할 수 있게 해줍니다. 별명들은 일반적으로 특히, 긴 패키지 명을 사용하고 있다면, 훨씬 짧은 이름을 사용하며, 직렬화된 형태의 이벤트를 더 작게 만듭니다. XML을 사용하므로, XML에서 제거된 각각의 문자들로 두 배의 효과를 얻습니다. (하나는 시작 태그이고 나머지는 종료 태그입니다) XStream에서 보다 고급 주제는 사용자 정의 컨버터(converter)를 생성하는 것입니다. 기본 리플랙션(reflection) 기반의 컨버터들은 간단하지만, 가장 최적화된 XML을 생성하지는 않습니다. 항상 생성된 XML을 유심히 살펴보고 모든 정보가 원래의 인스턴스를 재구성하는 데 필요한지 봐야 합니다.

가능하다면 업 캐스터의 사용을 자제하세요. 필드명이 변경되었을 때, XStream은 변경된 필드에 별명의 사용을 허용합니다. 수정 번호 0의 이벤트가 있다 하고, 해당 이벤트가 "clientId"라는 항목을 사용한다고 가정합니다. 사업적 측면에선 "고객(customer)"라는 용어를 선호 하므로, 수정 번호 1의 이벤트를 생성하고 "customerId"라는 속성을 가지도록 해봅니다. XStream은 해당 속성에 별명을 사용하도록 설정하여 이런 변경 사항을 처리할 수 있도록 해줍니다. 다음과 같은 순서로 두 개의 별명을 설정해야 하는데, 첫 번째는 "customerId" 별명을 "clientId"에 사용하고 두 번째로 "customerId" 별명을 "customerId"에 사용합니다. 이 설정을 통해 XStream으로 하여금 "customerId"라는 속성을 발견하면, 이 속성에 해당하는 XML 엘레멘트 "customerId"를 사용하도록 합니다. (두 번째 설정은 첫 번째를 재정의(override) 합니다) 반면 XStream은 "clientId"라는 XML 엘레멘트를 만나게 되면, 해당 엘레멘트를 "customerId" 속성으로 처리하게 됩니다. 더 많은 내용은 XStream 문서를 참고하세요.

최고의 성능을 위해서, 리플랙션 기반의 메커니즘을 사용하지 않는 것이 좋습니다. 리플랙션 기반의 메커니즘을 사용하지 않을 때에는, 직렬화 메커니즘을 직접 정의하여 사용하는 것이 가장 좋은 방법일 것입니다. `DataInputStream`과 `DataOutputStream`들을 통해 쉽게 이벤트의 내용을 output stream으로 보낼 수 있습니다. `ByteArrayOutputStream`과 `ByteArrayInputStream`을 통해 바이트 어레이(byte array)로 일고 쓸 수 있습니다.

중복 직렬화 방지
----------------------------------

분산 시스템에서 특히, 이벤트 메시지들을 여러 번 직렬화할 필요가 있습니다. Axon의 컴포넌트들은 `SerializationAware` 메시지에 대해 지원을 하여, 만약 `SerializationAware` 메시지를 발견하면, 단순히 메시지의 페이로드를 직렬화 객체에 전달하지 않고 `SerializationAware`의 직렬화 메서드를 호출하여 객체를 직렬화합니다. `SerializationAware` 메서드들은 같은 직렬화 객체를 사용하여 여러 번 직렬화를 하는 경우 같은 직렬화된 객체를 반환합니다. (`SerializedObjectHolder`를 참조하시면 됩니다) 이를 통해 성능 개선을 할 수 있습니다.

직접 메시지를 직렬화하면서 `SerializationAware`의 최적화 이점을 원한다면, 메시지의 페이로드와 메터 데이터를 직렬화하기 위해 `MessageSerializer` 클래스를 사용하세요. 모든 최적화 로직은 `MessageSerializer`에 구현되어 있습니다. 상세 내용은 `MessageSerializer`의 JavaDoc을 참고하세요.

이벤트를 위한 다른 직렬화 객체 사용
-------------------------------

이벤트 소싱을 사용할 때, 직렬화된 이벤트들은 오랜 시간 동안 지속할 수 있으므로, 직렬화 객체의 형식을 신중히 선택해야 합니다. 이벤트들에 대해 별도의 직렬화 객체를 설정하여 사용하는 것을 고려해야 하며, 이벤트들을 저장하는 방법을 조심하여 최적화해야 합니다. Jackson에 의해 생성된 JSON 형식은 XStream의 XML 형식보다 일반적으로 오랜 기간 지속하는 이벤트에 더욱 더 적합합니다.

사용자 정의 식별자 생성
============================

Axon Framework은 `IdentifierFactory`를 사용하여 이벤트 혹은 명령들에 대한 모든 식별자를 생성합니다. 기본 `IdentifierFactory`는 무작위로 생성된 `java.util.UUID` 기반의 식별자들을 사용합니다. 비록 `java.util.UUID` 기반의 식별자들이 사용하기에 안전하긴 하지만, 생성하는 프로세스는 성능상 뛰어나진 않습니다.

`IdentifierFactory`는 사용 가능한 구현체를 찾기 위해 Java(Java 6 이후의)의 서비스로더(ServiceLoader) 메커니즘을 사용하는 추상 팩토리 입니다. 즉, `IdentifierFactory`를 직접 구현하여 사용할 수 있습니다. 직접 `IdentifierFactory`를 구현한 경우, "`/META-INF/services/org.axonframework.common.IdentifierFactory`" 파일에 해당 구현체의 이름을 적어 주어야 합니다. Java의 서비스로더 메커니즘은 해당 파일을 발견하여 파일 안에 명시된 클래스의 인스턴스를 생성합니다.

`IdentifierFactory`를 구현하기 위한 몇 가지 필요 사항들은 다음과 같습니다. 구현체는 반드시 아래의 사항들을 만족해야 합니다.

-   패키지 명을 포함한 전체 클래스 명이 클래스 패스 상의 `/META-INF/services/org.axonframework.common.IdentifierFactory` 파일에 포함되어야 합니다. 

-   매개 변수를 가지지 않는 기본 생성자를 가지고 있어야 합니다.

-   `IdentifierFactory`를 상속해야 합니다.

-   애플리케이션의 컨텍스트 클래스로더 혹은 `IdentifierFactory` 클래스를 적재한 클래스로더가 접근할 수 있어야 합니다.

-   그리고 반드시 스레드 세이프(다중 스레드 환경에서 부작용 없이 사용 가능) 해야 합니다.
